{"version":3,"file":"index-B_75CXab.js","sources":["../../src/main.js"],"sourcesContent":["import * as BABYLON from \"@babylonjs/core\";\r\nimport \"@babylonjs/loaders\";\r\n\r\nasync function startAR() {\r\n    const canvas = document.getElementById(\"canvas\");\r\n    const engine = new BABYLON.Engine(canvas, true);\r\n    const scene = new BABYLON.Scene(engine);\r\n\r\n    const camera = new BABYLON.FreeCamera(\"camera\", new BABYLON.Vector3(0, 0, 0), scene);\r\n    \r\n    // Add light for visibility\r\n    const light = new BABYLON.HemisphericLight(\"light\", new BABYLON.Vector3(0, 1, 0), scene);\r\n    light.intensity = 1;\r\n\r\n    // Create XR experience with proper configuration for AR\r\n    const xr = await scene.createDefaultXRExperienceAsync({\r\n        uiOptions: {\r\n            sessionMode: \"immersive-ar\",\r\n            referenceSpaceType: \"unbounded\" // Changed from \"local\" to \"unbounded\" as recommended\r\n        },\r\n        optionalFeatures: true\r\n    });\r\n\r\n    let modelMesh = null;\r\n    let modelPlaced = false;\r\n\r\n    // Load the 3D model\r\n    const result = await BABYLON.SceneLoader.ImportMeshAsync(\r\n        \"\", \"./\",\r\n        \"arm_chair__furniture.glb\",\r\n        scene\r\n    );\r\n\r\n    modelMesh = result.meshes[0];\r\n    modelMesh.setEnabled(false); // Hide until placed\r\n\r\n    // When XR session starts, set up interaction\r\n    xr.baseExperience.sessionManager.onXRSessionInit.add(() => {\r\n        console.log(\"AR Session started!\");\r\n        \r\n        const fm = xr.baseExperience.featuresManager;\r\n        \r\n        // Try to enable image tracking as optional feature\r\n        try {\r\n            const imageTracking = fm.enableFeature(\r\n                BABYLON.WebXRFeatureName.IMAGE_TRACKING,\r\n                \"latest\",\r\n                {\r\n                    images: [\r\n                        {\r\n                            src: \"./furniture.jpg\", // Make sure this matches your actual file\r\n                            estimatedRealWorldWidth: 0.085\r\n                        }\r\n                    ]\r\n                },\r\n                false, // Not auto-attached\r\n                false  // Optional feature - won't fail if not supported\r\n            );\r\n            \r\n            if (imageTracking) {\r\n                console.log(\"Image tracking available!\");\r\n                \r\n                imageTracking.onTrackedImageUpdatedObservable.add(image => {\r\n                    if (!modelMesh) return;\r\n                    \r\n                    const pose = image.realWorldTransform;\r\n                    if (pose) {\r\n                        modelMesh.setEnabled(true);\r\n                        modelPlaced = true;\r\n                        modelMesh.position.copyFrom(pose.position);\r\n                        modelMesh.rotationQuaternion = pose.rotationQuaternion;\r\n                        modelMesh.scaling.setAll(0.1);\r\n                    }\r\n                });\r\n            }\r\n        } catch (e) {\r\n            console.log(\"Image tracking not supported, using hit-test fallback\");\r\n        }\r\n        \r\n        // Fallback: Use hit-test for surface placement\r\n        try {\r\n            const hitTest = fm.enableFeature(\r\n                BABYLON.WebXRFeatureName.HIT_TEST, \r\n                \"latest\",\r\n                {\r\n                    // Ray pointing forward from camera\r\n                    offsetRay: { \r\n                        origin: { x: 0, y: 0, z: 0 }, \r\n                        direction: { x: 0, y: 0, z: -1 } \r\n                    }\r\n                }\r\n            );\r\n            \r\n            if (hitTest) {\r\n                console.log(\"Hit-test enabled for surface placement\");\r\n                \r\n                // Show placement indicator\r\n                const indicator = BABYLON.MeshBuilder.CreateTorus(\"indicator\", {\r\n                    diameter: 0.15,\r\n                    thickness: 0.01\r\n                }, scene);\r\n                indicator.isVisible = false;\r\n                \r\n                // Update indicator position with hit test\r\n                hitTest.onHitTestResultObservable.add((results) => {\r\n                    if (results.length) {\r\n                        const hitResult = results[0];\r\n                        indicator.isVisible = true;\r\n                        indicator.position = hitResult.position;\r\n                        indicator.rotationQuaternion = hitResult.rotationQuaternion;\r\n                    } else {\r\n                        indicator.isVisible = false;\r\n                    }\r\n                });\r\n                \r\n                // Place model on tap\r\n                scene.onPointerObservable.add((pointerInfo) => {\r\n                    if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERDOWN) {\r\n                        if (indicator.isVisible && !modelPlaced) {\r\n                            // Place the model at indicator position\r\n                            modelMesh.setEnabled(true);\r\n                            modelMesh.position = indicator.position.clone();\r\n                            modelMesh.rotationQuaternion = indicator.rotationQuaternion.clone();\r\n                            modelMesh.scaling.setAll(0.1);\r\n                            modelPlaced = true;\r\n                            indicator.isVisible = false;\r\n                            console.log(\"Model placed on surface!\");\r\n                        } else if (modelPlaced) {\r\n                            // Rotate model if already placed\r\n                            modelMesh.rotation.y += 0.4;\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        } catch (e) {\r\n            console.log(\"Hit-test not available, using direct placement\");\r\n            \r\n            // Ultimate fallback: Place model directly in front after delay\r\n            setTimeout(() => {\r\n                if (!modelPlaced && modelMesh) {\r\n                    modelMesh.setEnabled(true);\r\n                    modelMesh.position = new BABYLON.Vector3(0, 0, -1.5); // 1.5 meters in front\r\n                    modelMesh.scaling.setAll(0.1);\r\n                    modelPlaced = true;\r\n                    console.log(\"Model placed at fixed position\");\r\n                }\r\n            }, 2000);\r\n        }\r\n    });\r\n\r\n    // Simple floating animation\r\n    scene.onBeforeRenderObservable.add(() => {\r\n        if (modelPlaced && modelMesh) {\r\n            modelMesh.position.y += Math.sin(performance.now() * 0.002) * 0.001;\r\n        }\r\n    });\r\n\r\n    engine.runRenderLoop(() => scene.render());\r\n    window.addEventListener(\"resize\", () => engine.resize());\r\n    \r\n    console.log(\"AR ready. Tap the AR button to start!\");\r\n}\r\n\r\nstartAR();"],"names":["startAR","canvas","engine","BABYLON.Engine","scene","BABYLON.Scene","BABYLON.FreeCamera","BABYLON.Vector3","light","BABYLON.HemisphericLight","xr","modelMesh","modelPlaced","BABYLON.SceneLoader","fm","imageTracking","BABYLON.WebXRFeatureName","image","pose","hitTest","indicator","BABYLON.MeshBuilder","results","hitResult","pointerInfo","BABYLON.PointerEventTypes"],"mappings":"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"}